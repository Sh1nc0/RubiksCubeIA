<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="Up" href="StateProblem.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Miscellaneous" rel="Chapter" href="Miscellaneous.html">
<link title="Pairs" rel="Chapter" href="Pairs.html">
<link title="Additive" rel="Chapter" href="Additive.html">
<link title="Ord" rel="Chapter" href="Ord.html">
<link title="StateProblem" rel="Chapter" href="StateProblem.html">
<link title="DepthLimit" rel="Chapter" href="DepthLimit.html">
<link title="Naive" rel="Chapter" href="Naive.html">
<link title="Meta" rel="Chapter" href="Meta.html">
<link title="IDS" rel="Chapter" href="IDS.html"><link title="Base types " rel="Section" href="#5_Basetypes">
<link title="Transitions" rel="Section" href="#5_Transitions">
<link title="Problem" rel="Section" href="#5_Problem">
<link title="Solutions" rel="Section" href="#5_Solutions">
<link title="Progress" rel="Section" href="#5_Progress">
<link title="Conversions" rel="Section" href="#5_Conversions">
<link title="Conversions to string" rel="Section" href="#5_Conversionstostring">
<title>StateProblem.StateProblem</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="StateProblem.html" title="StateProblem">Up</a>
&nbsp;</div>
<h1>Functor <a href="type_StateProblem.StateProblem.html">StateProblem.StateProblem</a></h1>

<pre><span id="MODULEStateProblem"><span class="keyword">module</span> StateProblem</span> <code class="code">(</code><code class="code">S</code><code class="code"> : </code><code class="type"><a href="StateProblem.STATE.html">STATE</a></code><code class="code">) </code> <code class="code">(</code><code class="code">D</code><code class="code"> : </code><code class="type"><a href="StateProblem.OPERATION.html">OPERATION</a></code><code class="code">) </code> <code class="code">(</code><code class="code">C</code><code class="code"> : </code><code class="type"><a href="Additive.ADDITIVE.html">Additive.ADDITIVE</a></code><code class="code">) </code>: <code class="code">sig</code> <a href="StateProblem.StateProblem.html">..</a> <code class="code">end</code></pre><div class="info module top">
<div class="info-desc">
<p>The functor <code class="code">StateProblem</code> takes three modules that describe basic types and builds a module with the convenient signature <code class="code">STATEPROBLEM</code> to be used with solvers.</p>
</div>
</div>
<table border="0" cellpadding="3" width="100%">
<tr>
<td align="left" valign="top" width="1%%"><b>Parameters: </b></td>
<td>
<table class="paramstable">
<tr>
<td align="center" valign="top" width="15%">
<code>S</code></td>
<td align="center" valign="top">:</td>
<td><code class="type"><a href="StateProblem.STATE.html">STATE</a></code>
<tr>
<td align="center" valign="top" width="15%">
<code>D</code></td>
<td align="center" valign="top">:</td>
<td><code class="type"><a href="StateProblem.OPERATION.html">OPERATION</a></code>
<tr>
<td align="center" valign="top" width="15%">
<code>C</code></td>
<td align="center" valign="top">:</td>
<td><code class="type"><a href="Additive.ADDITIVE.html">Additive.ADDITIVE</a></code>
</table>
</td>
</tr>
</table>
<hr width="100%">
<h6 id="5_Basetypes">Base types </h6>
<pre><span id="TYPEstate"><span class="keyword">type</span> <code class="type"></code>state</span> = <code class="type">S.state</code> </pre>


<pre><span id="TYPEop"><span class="keyword">type</span> <code class="type"></code>op</span> = <code class="type">D.op</code> </pre>


<pre><span id="TYPEnum"><span class="keyword">type</span> <code class="type"></code>num</span> = <code class="type">C.c</code> </pre>

<h6 id="5_Transitions">Transitions</h6>
<pre><code><span id="TYPEtransition"><span class="keyword">type</span> <code class="type"></code>transition</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtransition.startState">startState</span>&nbsp;: <code class="type"><a href="StateProblem.StateProblem.html#TYPEstate">state</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtransition.operation">operation</span>&nbsp;: <code class="type"><a href="StateProblem.StateProblem.html#TYPEop">op</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtransition.endState">endState</span>&nbsp;: <code class="type"><a href="StateProblem.StateProblem.html#TYPEstate">state</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtransition.cost">cost</span>&nbsp;: <code class="type"><a href="StateProblem.StateProblem.html#TYPEnum">num</a></code>;</code></td>

</tr></table>
<code>}</code>

<div class="info ">
<div class="info-desc">
<p>A transformation is a triplet consisting of the /image/ of some state through a given operation.
 This encodes:</p>

<ul>
<li>the description of the actual multi-valued function, 'operation',</li>
</ul>
<ul>
<li>one of the corresponding images, 'state', as well as</li>
</ul>
<ul>
<li>an accompanying function that provides the 'cost' of the operation between the antecedent and the image states.</li>
</ul>
<p><b>Nota</b>
    Either the 'startState' or 'endState' attribute may seem unnecessary.
    Although slightly redundant, in most cases it is better to have them both rather than not.
    This avoids some additional parameter, or some zipping.
    In fact, since a transition is an /edge/ on a graph, it "naturally" contains its origin /and/ its destination.</p>
</div>
</div>


<pre><span id="TYPEsuccessors"><span class="keyword">type</span> <code class="type"></code>successors</span> = <code class="type"><a href="StateProblem.StateProblem.html#TYPEstate">state</a> -&gt; <a href="StateProblem.StateProblem.html#TYPEtransition">transition</a> list</code> </pre>
<div class="info ">
<div class="info-desc">
<p>Determining the successors of a node is the basic step for solving a problem.
 In a state-based approach, they represent the directed edges from an origin state to a destination state.
 The edge is labelled by a description of the applied transformation (i.e., the actual underlying function) as well as the cost of applying it.</p>

<p><b>Nota</b>
    A single transformation encompasses several aspects:</p>

<ul>
<li>through the descriptions, we have a kind of curried view of a function,</li>
</ul>
<ul>
<li>most often, functions do have pre-conditions, which remain implicit and hidden in the function itself here,</li>
</ul>
<ul>
<li>functions do have post-conditions too, especially for limited the exploration by removing dead-ends, which can be applied by composing the generation and the filtering,</li>
</ul>
<ul>
<li>the cost is a by-product of applying a transformation and is better formalised as an independent function.</li>
</ul>
<p><b>Nota</b>
    Also, as a possible post-condition, the function could avoid to generate successors from dead-end states, i.e., states for which we are sure that no final state is attainable.
    Alternatively, these dead-end states could be totally avoided from their parent successors.
    However, this two techniques somewhat interfere with the solvers that could plainly ask for this kind of property.</p>
</div>
</div>

<h6 id="5_Problem">Problem</h6>
<pre><code><span id="TYPEstate_problem"><span class="keyword">type</span> <code class="type"></code>state_problem</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstate_problem.successors">successors</span>&nbsp;: <code class="type"><a href="StateProblem.StateProblem.html#TYPEsuccessors">successors</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>the graph is /implicitly/ described thanks to transformations from any given state to its successors</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstate_problem.isFinalState">isFinalState</span>&nbsp;: <code class="type"><a href="StateProblem.StateProblem.html#TYPEstate">state</a> -&gt; bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>the final states form a subset of 'states', described in comprehension thanks to a predicate</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
<code>}</code>

<div class="info ">
<div class="info-desc">
<p>A problem to solve through a graph-based approach consists mainly of two functions:</p>

<ul>
<li>a function (representing formally a set of functions) that allows to generate new states from known ones,</li>
</ul>
<ul>
<li>a predicate that determines whether a given state satisfies the solution requirements.</li>
</ul>
<p><b>Nota</b>
    The transformation function is described in detail through its dedicated type 'Successors'.</p>

<p><b>Nota</b>
    A functional description of a problem is the only one feasible for infinite graphs, or even only large graphs.</p>

<p>This data type is /not/ essential.
 In fact, it is barely used in practice!
 It appears in relationship with its extensional variant, 'ExtensionStateProblem', which is an actual graph.
 What is to be used are its associated data types:  'Transition', 'Successors', and 'Solution'.
 (Themselves could even be represented as mere tuples and lists of tuples ...)</p>
</div>
</div>


<pre><code><span id="TYPEextension_state_problem"><span class="keyword">type</span> <code class="type"></code>extension_state_problem</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTextension_state_problem.states">states</span>&nbsp;: <code class="type"><a href="StateProblem.StateProblem.html#TYPEstate">state</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>all the known nodes of the state graph</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTextension_state_problem.theInitialState">theInitialState</span>&nbsp;: <code class="type"><a href="StateProblem.StateProblem.html#TYPEstate">state</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>the initial state belongs to 'states'</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTextension_state_problem.finalStates">finalStates</span>&nbsp;: <code class="type"><a href="StateProblem.StateProblem.html#TYPEstate">state</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>the final states form a subset of 'states'</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTextension_state_problem.edges">edges</span>&nbsp;: <code class="type">(<a href="StateProblem.StateProblem.html#TYPEstate">state</a> * <a href="StateProblem.StateProblem.html#TYPEop">op</a> *<br>        <a href="StateProblem.StateProblem.html#TYPEstate">state</a> * <a href="StateProblem.StateProblem.html#TYPEnum">num</a>)<br>       list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>edges are labelled both by a description and a cost (possibly uniformly unitary)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
<code>}</code>

<div class="info ">
<div class="info-desc">
<p>Being represented by a graph, in finite cases a problem can be fully provided (or generated).
 It is a mere labelled graph!</p>

<p>This form is also provided for testing purposes.</p>

<p><b>Nota</b>
    An additional information is provided.
    It is some initial state.
    In other words, we are dealing with a problem /instance/ rather than a problem /class/.</p>

<p><b>Constraints</b></p>

<ul>
<li>The states must be comparable by equality.</li>
</ul>
<ul>
<li>The costs must be numeric values.</li>
</ul>
<ul>
<li>The three generic types must be "showable."</li>
</ul>
</div>
</div>


<pre><span id="VALmkExtensionStateProblem"><span class="keyword">val</span> mkExtensionStateProblem</span> : <code class="type">ss:state list -&gt;<br>       i:state -&gt;<br>       fs:state list -&gt;<br>       es:(state * <a href="StateProblem.StateProblem.html#TYPEop">op</a> * state *<br>           <a href="StateProblem.StateProblem.html#TYPEnum">num</a>)<br>          list -&gt;<br>       extension_state_problem</code></pre><div class="info ">
<div class="info-desc">
<p>A smart constructor is provided, which is a better solution than the default instance for initialising a graph.</p>

<p><b>Pre-condition</b></p>

<ul>
<li>The initial state is a member of the states.</li>
<li>The final states are included in the states.</li>
<li>The origin and destination states of the edges are included in the states.</li>
</ul>
<p><b>Time complexity</b></p>

<ul>
<li>$O(m.n)$ where $n$ is the number of states and $m$ is the sum of the number of nodes in the final states as well as on both side of the edges plus the initial state.</li>
</ul>
<ul>
<li>$O(n^2)$ for a complete graph.</li>
</ul>
</div>
<ul class="info-attributes">
<li><b>Returns</b> the corresponding graph should the pre-condition be fulfilled</li>
</ul>
</div>
<div class="param_info"><table border="0" cellpadding="3" width="100%">
<tr>
<td align="left" valign="top" width="1%"><b>Parameters: </b></td>
<td>
<table class="paramstable">
<tr>
<td align="center" valign="top" width="15%" class="code">
ss</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">state list</code><div>
the states of the graph given in extension
</tr>
<tr>
<td align="center" valign="top" width="15%" class="code">
i</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">state</code><div>
some initial state of the graph
</tr>
<tr>
<td align="center" valign="top" width="15%" class="code">
fs</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">state list</code><div>
the final states in the graph
</tr>
<tr>
<td align="center" valign="top" width="15%" class="code">
es</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">(state * <a href="StateProblem.StateProblem.html#TYPEop">op</a> * state * <a href="StateProblem.StateProblem.html#TYPEnum">num</a>)<br>       list</code><div>
a set of labelled edges with a description and a cost
</tr>
</table>
</td>
</tr>
</table></div>

<pre><span id="VALisExtensionStateProblem"><span class="keyword">val</span> isExtensionStateProblem</span> : <code class="type">extension_state_problem -&gt; bool</code></pre><div class="info ">
<div class="info-desc">
<p>A predicate that verifies that the constraints on the type 'ExtensionStateProblem' are satisfied.</p>
</div>
<ul class="info-attributes">
<li><b>Returns</b> true if, and only if, the initial as well as final states belong to the set of states, and all the edges link known states with a positive cost</li>
</ul>
</div>
<div class="param_info"><table border="0" cellpadding="3" width="100%">
<tr>
<td align="left" valign="top" width="1%"><b>Parameters: </b></td>
<td>
<table class="paramstable">
<tr>
<td align="center" valign="top" width="15%" class="code">
p</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">extension_state_problem</code><div>
a problem described in extension
</tr>
</table>
</td>
</tr>
</table></div>
<h6 id="5_Solutions">Solutions</h6>
<pre><span id="TYPEsolution"><span class="keyword">type</span> <code class="type"></code>solution</span> = <code class="type"><a href="StateProblem.StateProblem.html#TYPEtransition">transition</a> list</code> </pre>
<div class="info ">
<div class="info-desc">
<p>A solution is a path in the graph from some initial state to a final state, made of consecutive operations.</p>

<p>Of course, these consecutive operations must be actually linked to each other, and the last state be actually a final state.
 This is checked by the 'isSolution' predicate.</p>
</div>
</div>


<pre><span id="VALisSolution"><span class="keyword">val</span> isSolution</span> : <code class="type">t:(state -&gt; transition list) -&gt;<br>       f:(state -&gt; bool) -&gt; i:state -&gt; ts:transition list -&gt; bool</code></pre><div class="info ">
<div class="info-desc">
<p>This predicate verifies whether a claimed solution is indeed a solution with respect to a problem.
 For this to be true:</p>

<ul>
<li>the last state of the expected solution must be a final state,</li>
</ul>
<ul>
<li>each couple of consecutive states must belong to the authorised transformations, and</li>
</ul>
<ul>
<li>the first transformation must be applicable to the initial state.</li>
</ul>
<p><b>Nota</b>
    As a special case, an empty list is also a solution, should the initial state be already a solution.</p>

<p><b>Nota</b>
    It is possible to find several solution states on a solution path.
    It is not the goal of this predicate to impose the minimality of a solution.</p>
</div>
<ul class="info-attributes">
<li><b>Returns</b> true if, and only if, all the transformation can be applied in sequence from the initial state and end up in a final state</li>
</ul>
</div>
<div class="param_info"><table border="0" cellpadding="3" width="100%">
<tr>
<td align="left" valign="top" width="1%"><b>Parameters: </b></td>
<td>
<table class="paramstable">
<tr>
<td align="center" valign="top" width="15%" class="code">
t</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">state -&gt; transition list</code><div>
a transformation function that generates the successors of a given state
</tr>
<tr>
<td align="center" valign="top" width="15%" class="code">
f</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">state -&gt; bool</code><div>
the predicate that determines if a state is a final state
</tr>
<tr>
<td align="center" valign="top" width="15%" class="code">
i</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">state</code><div>
the initial state to which it is presumed to apply
</tr>
<tr>
<td align="center" valign="top" width="15%" class="code">
ts</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">transition list</code><div>
a potential solution as a list of transformations
</tr>
</table>
</td>
</tr>
</table></div>

<pre><span id="VALsolutionCost"><span class="keyword">val</span> solutionCost</span> : <code class="type">transition list -&gt; C.c</code></pre><div class="info ">
<div class="info-desc">
<p>The cost of a solution is the sum of the costs of its transformations.</p>

<p><b>Nota</b>
    This is different from the cost of /finding/ a solution, which is to the number of generated states before reaching a solution.</p>
</div>
<ul class="info-attributes">
<li><b>Returns</b> the overall cost os <code class="code">s</code> as the sum of the costs of its transitions</li>
</ul>
</div>
<div class="param_info"><table border="0" cellpadding="3" width="100%">
<tr>
<td align="left" valign="top" width="1%"><b>Parameters: </b></td>
<td>
<table class="paramstable">
<tr>
<td align="center" valign="top" width="15%" class="code">
s</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">transition list</code><div>
a (supposed to be) solution
</tr>
</table>
</td>
</tr>
</table></div>

<pre><span id="VALchildrenStates"><span class="keyword">val</span> childrenStates</span> : <code class="type">p:extension_state_problem -&gt; state -&gt; transition list</code></pre><div class="info ">
<div class="info-desc">
<p>From a descriptive to a function view of the edges\/transformations of a problem.</p>

<p>Thanks to currying, this function can be called only with its first parameter in order to return the function required by the solvers.</p>

<p><b>Post-condition</b></p>

<ul>
<li>The generated predicate is satisfied by all the final states of the problem.</li>
</ul>
<ul>
<li>Conversely, the non-final states do not satisfy the predicate.</li>
</ul>
</div>
<ul class="info-attributes">
<li><b>Returns</b> the function describing the transformations of <code class="code">p</code></li>
</ul>
</div>
<div class="param_info"><table border="0" cellpadding="3" width="100%">
<tr>
<td align="left" valign="top" width="1%"><b>Parameters: </b></td>
<td>
<table class="paramstable">
<tr>
<td align="center" valign="top" width="15%" class="code">
p</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">extension_state_problem</code><div>
a generic problem
</tr>
<tr>
<td align="center" valign="top" width="15%" class="code">
i</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">state</code><div>
DO NOT USE DIRECTLY, use partial application to get a function
</tr>
</table>
</td>
</tr>
</table></div>

<pre><span id="VALisAFinalState"><span class="keyword">val</span> isAFinalState</span> : <code class="type">extension_state_problem -&gt; state -&gt; bool</code></pre><div class="info ">
<div class="info-desc">
<p>From a descriptive to a predicative view of the final states of a problem.</p>

<p><b>Post-condition</b></p>

<ul>
<li>The generated predicate is satisfied by all the final states of the problem.</li>
</ul>
<ul>
<li>Conversely, the non final states do not satisfy the predicate.</li>
</ul>
</div>
<ul class="info-attributes">
<li><b>Returns</b> the predicate determining if the state is a final one</li>
</ul>
</div>
<div class="param_info"><table border="0" cellpadding="3" width="100%">
<tr>
<td align="left" valign="top" width="1%"><b>Parameters: </b></td>
<td>
<table class="paramstable">
<tr>
<td align="center" valign="top" width="15%" class="code">
p</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">extension_state_problem</code><div>
a generic problem
</tr>
<tr>
<td align="center" valign="top" width="15%" class="code">
s</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">state</code><div>
DO NOT USE DIRECTLY, use partial application to get a predicate
</tr>
</table>
</td>
</tr>
</table></div>
<h6 id="5_Progress">Progress</h6>
<pre><span id="VALbuild"><span class="keyword">val</span> build</span> : <code class="type">n:int -&gt;<br>       t:(state -&gt; transition list) -&gt;<br>       f:'a -&gt;<br>       i:state -&gt;<br>       ss:state list -&gt;<br>       os:(state * <a href="StateProblem.StateProblem.html#TYPEop">op</a> * <a href="StateProblem.StateProblem.html#TYPEstate">state</a> *<br>           <a href="StateProblem.StateProblem.html#TYPEnum">num</a>)<br>          list -&gt;<br>       q:state list * state list -&gt;<br>       state list *<br>       (state * <a href="StateProblem.StateProblem.html#TYPEop">op</a> * <a href="StateProblem.StateProblem.html#TYPEstate">state</a> *<br>        <a href="StateProblem.StateProblem.html#TYPEnum">num</a>)<br>       list</code></pre><div class="info ">
<div class="info-desc">
<p>Development of (part of) a graph from a functional description.</p>

<p><b>Nota</b>
    The graph is created in a breadth-first search way.</p>

<p><b>Time complexity</b> O(n^2).</p>
</div>
<ul class="info-attributes">
<li><b>Returns</b> both the fully developed nodes and the solely reached ones along with their edges</li>
</ul>
</div>
<div class="param_info"><table border="0" cellpadding="3" width="100%">
<tr>
<td align="left" valign="top" width="1%"><b>Parameters: </b></td>
<td>
<table class="paramstable">
<tr>
<td align="center" valign="top" width="15%" class="code">
n</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">int</code><div>
maximal number of fully developed nodes to create
</tr>
<tr>
<td align="center" valign="top" width="15%" class="code">
t</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">state -&gt; transition list</code><div>
the transformation function describing the transformations of p
</tr>
<tr>
<td align="center" valign="top" width="15%" class="code">
f</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">'a</code><div>
the predicate determining if the state is a final one
</tr>
<tr>
<td align="center" valign="top" width="15%" class="code">
i</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">state</code><div>
the initial state
</tr>
<tr>
<td align="center" valign="top" width="15%" class="code">
ss</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">state list</code><div>
the list of found nodes with followed out-going edges
</tr>
<tr>
<td align="center" valign="top" width="15%" class="code">
os</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">(state * <a href="StateProblem.StateProblem.html#TYPEop">op</a> * <a href="StateProblem.StateProblem.html#TYPEstate">state</a> *<br>        <a href="StateProblem.StateProblem.html#TYPEnum">num</a>)<br>       list</code><div>
the list of travelled edges
</tr>
<tr>
<td align="center" valign="top" width="15%" class="code">
q</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">state list * state list</code><div>
a queue managed efficiently as a double (difference) list
</tr>
</table>
</td>
</tr>
</table></div>
<h6 id="5_Conversions">Conversions</h6>
<pre><span id="VALextension2comprehension"><span class="keyword">val</span> extension2comprehension</span> : <code class="type">extension_state_problem -&gt; state_problem</code></pre><div class="info ">
<div class="info-desc">
<p>The extensional (data) and intentional (functional) views of a problem are almost equivalent.
 They are equivalent if, and only if, the graph is small enough, i.e., finite, to be fully generated in its extensional version.
 In contrast, any data description can be transformed into a functional version.</p>
</div>
</div>
<div class="param_info"><table border="0" cellpadding="3" width="100%">
<tr>
<td align="left" valign="top" width="1%"><b>Parameters: </b></td>
<td>
<table class="paramstable">
<tr>
<td align="center" valign="top" width="15%" class="code">
g</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">extension_state_problem</code><div>

</tr>
</table>
</td>
</tr>
</table></div>

<pre><span id="VALcomprehension2extension"><span class="keyword">val</span> comprehension2extension</span> : <code class="type">n:int -&gt;<br>       t:(state -&gt; <a href="StateProblem.StateProblem.html#TYPEtransition">transition</a> list) -&gt;<br>       f:(state -&gt; bool) -&gt; i:state -&gt; extension_state_problem</code></pre><div class="info ">
<div class="info-desc">
<p>From a functional view to a descriptive view.</p>

<p><b>Nota</b>
    An additional parameter is given in order to avoid generating infinite graphs.
    It does not corresponds to the maximal number of nodes to create but rather (implementation-dependent) to the number of fully treated nodes, i.e., those for which all the children have been also developed.</p>

<p><b>Pre-condition</b></p>

<ul>
<li>The number of generated nodes is at least one, for the initial state.</li>
</ul>
<ul>
<li>The number of generated nodes varies from one to slightly more than n, depending on the size of the underlying graph but also it connectedness.
      Therefore, n is only a crude value given to this generator...</li>
</ul>
</div>
<ul class="info-attributes">
<li><b>Returns</b> the corresponding descriptive problem instance</li>
</ul>
</div>
<div class="param_info"><table border="0" cellpadding="3" width="100%">
<tr>
<td align="left" valign="top" width="1%"><b>Parameters: </b></td>
<td>
<table class="paramstable">
<tr>
<td align="center" valign="top" width="15%" class="code">
n</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">int</code><div>
some (almost) maximal number of nodes to create
</tr>
<tr>
<td align="center" valign="top" width="15%" class="code">
t</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">state -&gt; <a href="StateProblem.StateProblem.html#TYPEtransition">transition</a> list</code><div>
the transformation function describing the transformations of p
</tr>
<tr>
<td align="center" valign="top" width="15%" class="code">
f</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">state -&gt; bool</code><div>
the predicate determining if the state is a final one
</tr>
<tr>
<td align="center" valign="top" width="15%" class="code">
i</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">state</code><div>
the initial state
</tr>
</table>
</td>
</tr>
</table></div>
<h6 id="5_Conversionstostring">Conversions to <code class="code">string</code></h6>
<pre><span id="VALstring_of_state"><span class="keyword">val</span> string_of_state</span> : <code class="type">S.state -&gt; string</code></pre>
<pre><span id="VALstring_of_op"><span class="keyword">val</span> string_of_op</span> : <code class="type">D.op -&gt; string</code></pre>
<pre><span id="VALstring_of_transition"><span class="keyword">val</span> string_of_transition</span> : <code class="type">transition -&gt; string</code></pre><div class="param_info"><table border="0" cellpadding="3" width="100%">
<tr>
<td align="left" valign="top" width="1%"><b>Parameters: </b></td>
<td>
<table class="paramstable">
<tr>
<td align="center" valign="top" width="15%" class="code">
s</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">transition</code><div>

</tr>
</table>
</td>
</tr>
</table></div>

<pre><span id="VALstring_of_solution"><span class="keyword">val</span> string_of_solution</span> : <code class="type">transition list -&gt; string</code></pre><div class="param_info"><table border="0" cellpadding="3" width="100%">
<tr>
<td align="left" valign="top" width="1%"><b>Parameters: </b></td>
<td>
<table class="paramstable">
<tr>
<td align="center" valign="top" width="15%" class="code">
s</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">transition list</code><div>

</tr>
</table>
</td>
</tr>
</table></div>

<pre><span id="VALshort_solution"><span class="keyword">val</span> short_solution</span> : <code class="type">transition list -&gt; string</code></pre><div class="param_info"><table border="0" cellpadding="3" width="100%">
<tr>
<td align="left" valign="top" width="1%"><b>Parameters: </b></td>
<td>
<table class="paramstable">
<tr>
<td align="center" valign="top" width="15%" class="code">
s</td>
<td align="center" valign="top">:</td>
<td><div class="paramer-type">
<code class="type">transition list</code><div>

</tr>
</table>
</td>
</tr>
</table></div>
</body></html>
